I"	0<p><code class="language-plaintext highlighter-rouge">JSON Web Token</code>（缩写<code class="language-plaintext highlighter-rouge">JWT</code>）是目前最流行的跨域认证解决方案</p>

<h5 id="一跨域认证问题">一、跨域认证问题</h5>

<p>一般认证流程如下:</p>
<blockquote>
  <p>1、用户向服务器发送用户名和密码.<br />
2、服务器验证通过后,在当前对话（<code class="language-plaintext highlighter-rouge">session</code>）里面保存相关数据,比如用户角色、登录时间等等.<br />
3、服务器向用户返回一个<code class="language-plaintext highlighter-rouge">session_id</code>写入用户的<code class="language-plaintext highlighter-rouge">Cookie</code>.<br />
4、用户随后的每一次请求,都会通过<code class="language-plaintext highlighter-rouge">Cookie</code>将<code class="language-plaintext highlighter-rouge">session_id</code>传回服务器.<br />
5、服务器收到<code class="language-plaintext highlighter-rouge">session_id</code>找到前期保存的数据,由此得知用户的身份.</p>
</blockquote>

<p>这种模式的问题在于,扩展性（<code class="language-plaintext highlighter-rouge">scaling</code>）不好.单机当然没有问题,如果是服务器集群,或者是跨域的服务导向架构,就要求<code class="language-plaintext highlighter-rouge">session</code>数据共享,每台服务器都能够读取<code class="language-plaintext highlighter-rouge">session</code>.<br />
举例来说,<code class="language-plaintext highlighter-rouge">A</code>网站和<code class="language-plaintext highlighter-rouge">B</code>网站是同一家公司的关联服务.现在要求,用户只要在其中一个网站登录,再访问另一个网站就会自动登录,请问怎么实现？</p>

<blockquote>
  <p>一种解决方案是<code class="language-plaintext highlighter-rouge">session</code>数据持久化,写入数据库或别的持久层.各种服务收到请求后,都向持久层请求数据.这种方案的优点是架构清晰,缺点是工程量比较大.另外,持久层万一挂了,就会单点失败.</p>
</blockquote>

<blockquote>
  <p>另一种方案是服务器索性不保存<code class="language-plaintext highlighter-rouge">session</code>数据了,所有数据都保存在客户端,每次请求都发回服务器.<code class="language-plaintext highlighter-rouge">JWT</code>就是这种方案的一个代表.</p>
</blockquote>

<h5 id="二jwt的原理">二、<code class="language-plaintext highlighter-rouge">JWT</code>的原理</h5>

<p><code class="language-plaintext highlighter-rouge">JWT</code>的原理是,服务器认证以后,生成一个<code class="language-plaintext highlighter-rouge">JSON</code>对象,发回给用户,就像下面这样:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2022年11月7日0点0分"
}
</code></pre></div></div>

<p>以后,用户与服务端通信的时候,都要发回这个<code class="language-plaintext highlighter-rouge">JSON</code>对象.服务器完全只靠这个对象认定用户身份.为了防止用户篡改数据,服务器在生成这个对象的时候,会加上签名（详见后文）.</p>

<p>服务器就不保存任何<code class="language-plaintext highlighter-rouge">session</code>数据了,也就是说,服务器变成无状态了,从而比较容易实现扩展.</p>

<h5 id="三jwt的数据结构">三、<code class="language-plaintext highlighter-rouge">JWT</code>的数据结构</h5>

<p>实际的<code class="language-plaintext highlighter-rouge">JWT</code>大概就像下面这样:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.
eyJpc3MiOiJ5YW9kaWFuZGV2Lmd0NTIwLmNvbSIsImF1ZCI6Inlhb2RpYW5kZXYuZ3Q1MjAuY29tIiwiaWF0IjoxNjY3ODA5NDE2LCJuYmYiOjE2Njc4MDk0MTYsImV4cCI6MTY2ODQxNDIxNiwianRpIjpbMzgsInVzZXIiXX0.
GymCPwjEGpTEa-FnkS-vThZrmyIPO-eSsMYtuOPx1HY
</code></pre></div></div>

<p>它是一个很长的字符串,中间用点<code class="language-plaintext highlighter-rouge">.</code>分隔成三个部分.注意:<code class="language-plaintext highlighter-rouge">JWT</code>内部是没有换行的,这里只是为了便于展示,将它写成了三行行.</p>

<p><code class="language-plaintext highlighter-rouge">JWT</code>的三个部分依次如下:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Header（头部）
Payload（负载）
Signature（签名）
</code></pre></div></div>

<p>写成一行,就是下面的样子:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Header.Payload.Signature
</code></pre></div></div>

<p>下面依次介绍这三个部分.</p>

<h6 id="31-header">3.1 Header</h6>
<p><code class="language-plaintext highlighter-rouge">Header</code>部分是一个<code class="language-plaintext highlighter-rouge">JSON</code>对象,描述<code class="language-plaintext highlighter-rouge">JWT</code>的元数据,通常是下面的样子:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "alg": "HS256",
  "typ": "JWT"
}
</code></pre></div></div>
<p>上面代码中,<code class="language-plaintext highlighter-rouge">alg</code>属性表示签名的算法（<code class="language-plaintext highlighter-rouge">algorithm</code>）,默认是<code class="language-plaintext highlighter-rouge">HMAC SHA256</code>（写成 <code class="language-plaintext highlighter-rouge">HS256</code>）;<code class="language-plaintext highlighter-rouge">typ</code>属性表示这个令牌（<code class="language-plaintext highlighter-rouge">token</code>）的类型（<code class="language-plaintext highlighter-rouge">type</code>）,<code class="language-plaintext highlighter-rouge">JWT</code>令牌统一写为<code class="language-plaintext highlighter-rouge">JWT</code>.</p>

<p>最后,将上面的<code class="language-plaintext highlighter-rouge">JSON</code>对象使用<code class="language-plaintext highlighter-rouge">Base64URL</code>算法（详见后文）转成字符串.</p>

<h6 id="32-payload">3.2 Payload</h6>
<p><code class="language-plaintext highlighter-rouge">Payload</code>部分也是一个<code class="language-plaintext highlighter-rouge">JSON</code>对象,用来存放实际需要传递的数据.<code class="language-plaintext highlighter-rouge">JWT</code>规定了7个官方字段,供选用:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
</code></pre></div></div>
<p>除了官方字段,你还可以在这个部分定义私有字段,下面就是一个例子:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
</code></pre></div></div>
<p>注意:<code class="language-plaintext highlighter-rouge">JWT</code>默认是不加密的,任何人都可以读到,所以不要把秘密信息放在这个部分.</p>

<p>这个<code class="language-plaintext highlighter-rouge">JSON</code>对象也要使用<code class="language-plaintext highlighter-rouge">Base64URL</code>算法转成字符串.</p>

<h6 id="33-signature">3.3 Signature</h6>
<p><code class="language-plaintext highlighter-rouge">Signature</code>部分是对前两部分的签名,防止数据篡改.</p>

<p>首先,需要指定一个密钥（<code class="language-plaintext highlighter-rouge">secret</code>）这个密钥只有服务器才知道,不能泄露给用户.然后,使用<code class="language-plaintext highlighter-rouge">Header</code>里面指定的签名算法（默认是<code class="language-plaintext highlighter-rouge">HMAC SHA256</code>）,按照下面的公式产生签名.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
</code></pre></div></div>
<p>算出签名以后,把<code class="language-plaintext highlighter-rouge">Header、Payload、Signature</code>三个部分拼成一个字符串,每个部分之间用”点”<code class="language-plaintext highlighter-rouge">.</code>分隔,就可以返回给用户.</p>

<h6 id="34-base64url">3.4 Base64URL</h6>
<p>前面提到<code class="language-plaintext highlighter-rouge">Header</code>和<code class="language-plaintext highlighter-rouge">Payload</code>串型化的算法是<code class="language-plaintext highlighter-rouge">Base64URL</code>这个算法跟<code class="language-plaintext highlighter-rouge">Base64</code>算法基本类似,但有一些小的不同.</p>

<p><code class="language-plaintext highlighter-rouge">JWT</code>作为一个令牌（<code class="language-plaintext highlighter-rouge">token</code>）,有些场合可能会放到<code class="language-plaintext highlighter-rouge">URL</code>（比如<code class="language-plaintext highlighter-rouge">api.example.com/?token=xxx</code>）.<code class="language-plaintext highlighter-rouge">Base64</code>有三个字符<code class="language-plaintext highlighter-rouge">+、/和=</code>,在<code class="language-plaintext highlighter-rouge">URL</code> 里面有特殊含义,所以要被替换掉:<code class="language-plaintext highlighter-rouge">=被省略、+替换成-，/替换成_ </code>.这就是<code class="language-plaintext highlighter-rouge">Base64URL</code>算法.</p>

<h5 id="四jwt的使用方式">四、<code class="language-plaintext highlighter-rouge">JWT</code>的使用方式</h5>
<p>客户端收到服务器返回的<code class="language-plaintext highlighter-rouge">JWT</code>可以储存在<code class="language-plaintext highlighter-rouge">Cookie</code>里面,也可以储存在<code class="language-plaintext highlighter-rouge">localStorage</code>.</p>

<p>此后,客户端每次与服务器通信,都要带上这个<code class="language-plaintext highlighter-rouge">JWT</code>你可以把它放在<code class="language-plaintext highlighter-rouge">Cookie</code>里面自动发送,但是这样不能跨域,所以更好的做法是放在<code class="language-plaintext highlighter-rouge">HTTP</code>请求的头信息<code class="language-plaintext highlighter-rouge">Authorization</code>字段里面.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Authorization: Bearer &lt;token&gt;
</code></pre></div></div>
<p>另一种做法是,跨域的时候,<code class="language-plaintext highlighter-rouge">JWT</code>就放在<code class="language-plaintext highlighter-rouge">POST</code>请求的数据体里面.</p>

<h5 id="五jwt-的几个特点">五、<code class="language-plaintext highlighter-rouge">JWT</code> 的几个特点:</h5>
<blockquote>
  <ol>
    <li>JWT 默认是不加密,但也是可以加密的.生成原始 Token 以后,可以用密钥再加密一次;</li>
    <li>JWT 不加密的情况下,不能将秘密数据写入 JWT;</li>
    <li>JWT 不仅可以用于认证,也可以用于交换信息.有效使用 JWT,可以降低服务器查询数据库的次数;</li>
    <li>JWT 的最大缺点是,由于服务器不保存 session 状态,因此无法在使用过程中废止某个 token,或者更改 token 的权限.也就是说,一旦 JWT 签发了,在到期之前就会始终有效,除非服务器部署额外的逻辑.</li>
    <li>JWT 本身包含了认证信息,一旦泄露,任何人都可以获得该令牌的所有权限.为了减少盗用,JWT 的有效期应该设置得比较短.对于一些比较重要的权限,使用时应该再次对用户进行认证.</li>
    <li>为了减少盗用,JWT 不应该使用 HTTP 协议明码传输,要使用 HTTPS 协议传输.</li>
  </ol>
</blockquote>

<h5 id="六参考链接">六、参考链接</h5>

<p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">链接</a></p>

:ET