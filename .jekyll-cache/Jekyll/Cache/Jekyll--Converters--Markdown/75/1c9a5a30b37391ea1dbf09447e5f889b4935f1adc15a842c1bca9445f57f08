I"#.<h4 id="devserver-配置">devServer 配置</h4>

<p><strong>1.代理</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proxy: {
   '/phalapi':{                         // 要替换的位置
        target: 'http://www.abc.com'    // 被替换的目标地址
}
</code></pre></div></div>
<p><strong>说明:</strong></p>

<ul>
  <li>初始地址<code class="language-plaintext highlighter-rouge">localhost:8080/phalapi/login</code>的请求会被代理到<code class="language-plaintext highlighter-rouge">http://www.abc.com/phalapi/login</code></li>
</ul>

<p><strong>2.secure</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proxy: {
   '/phalapi':{                         // 要替换的位置
        target:'http://www.abc.com',    // 被替换的目标地址
        secure:true                     // 接受对方是https的接口
}
</code></pre></div></div>

<p><strong>3.changeOrigin</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proxy: {
   '/phalapi':{                         // 要替换的位置
        target:'http://www.abc.com',    // 被替换的目标地址
        secure:true,                    // 接受对方是https的接口
        changeOrigin:true               // 是否需要跨域
}
</code></pre></div></div>

<p><strong>4.pathRewrite</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proxy: {
   '/phalapi':{                         // 要替换的位置
        target:'http://www.abc.com',    // 被替换的目标地址
        secure:true,                    // 接受对方是https的接口
        changeOrigin:true,              // 是否需要跨域
        pathRewrite: {
            '^/phalapi':''
        }
}
</code></pre></div></div>

<p><strong>说明:</strong></p>

<ul>
  <li>路径重写: 例如<code class="language-plaintext highlighter-rouge">localhost:8080/phalapi/login</code>经过代理后会变为<code class="language-plaintext highlighter-rouge">http://www.abc.com/login</code>,前面的<code class="language-plaintext highlighter-rouge">/phalapi</code>就被替换为<code class="language-plaintext highlighter-rouge">空</code>了</li>
</ul>

<h4 id="更多配置">更多配置</h4>

<p>如果拥有单独的后端开发服务器<code class="language-plaintext highlighter-rouge">API</code>,并且希望在同域名下发送<code class="language-plaintext highlighter-rouge">API</code>请求,那么代理某些<code class="language-plaintext highlighter-rouge">URL</code>会很有用.<br />
解决开发环境的跨域问题(不用在去配置<code class="language-plaintext highlighter-rouge">nginx</code>和<code class="language-plaintext highlighter-rouge">host</code>).<br />
在<code class="language-plaintext highlighter-rouge">webpack.config.js</code>中配置<br />
下面简单介绍一下五个经常使用的场景</p>

<p>使用一:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mmodule.exports = {
    //...
    devServer: {
        proxy: {
            '/api': 'http://localhost:3000'
        }
    }
};
</code></pre></div></div>

<ul>
  <li>请求到<code class="language-plaintext highlighter-rouge">/api/xxx</code>现在会被代理到请求<code class="language-plaintext highlighter-rouge">http://localhost:3000/api/xxx</code>,例如<code class="language-plaintext highlighter-rouge">/api/user</code>现在会被代理到请求 <code class="language-plaintext highlighter-rouge">http://localhost:3000/api/user</code></li>
</ul>

<p>使用二:</p>

<p>如果你想要代码多个路径代理到同一个<code class="language-plaintext highlighter-rouge">target</code>下,你可以使用由一个或多个「具有<code class="language-plaintext highlighter-rouge">context</code>属性的对象」构成的数组:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = {
    //...
    devServer: {
        proxy: [{
            context: ['/auth', '/api'],
            target: 'http://localhost:3000',
        }]
    }
};
</code></pre></div></div>

<p>使用三:</p>

<p>如果你不想始终传递<code class="language-plaintext highlighter-rouge">/api</code>,则需要重写路径:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = {
    //...
    devServer: {
        proxy: {
            '/api': {
                target: 'http://localhost:3000',
                pathRewrite: {'^/api' : ''}
            }
        }
    }
};
</code></pre></div></div>

<ul>
  <li>请求到<code class="language-plaintext highlighter-rouge">/api/xxx</code>现在会被代理到请求<code class="language-plaintext highlighter-rouge">http://localhost:3000/xxx</code>,例如<code class="language-plaintext highlighter-rouge">/api/user</code>现在会被代理到请求<code class="language-plaintext highlighter-rouge">http://localhost:3000/user</code></li>
</ul>

<p>使用四:</p>

<p>默认情况下,不接受运行在<code class="language-plaintext highlighter-rouge">HTTPS</code>上,且使用了无效证书的后端服务器.如果你想要接受,只要设置<code class="language-plaintext highlighter-rouge">secure: false</code>就行.修改配置如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = {
    //...
    devServer: {
        proxy: {
            '/api': {
                target: 'https://other-server.example.com',
                secure: false
            }
        }
    }
};
</code></pre></div></div>

<p>使用五:</p>

<p>有时你不想代理所有的请求,可以基于一个函数的返回值绕过代理.<br />
在函数中你可以访问请求体、响应体和代理选项.必须返回<code class="language-plaintext highlighter-rouge">false</code>或路径,来跳过代理请求.<br />
例如:对于浏览器请求,你想要提供一个<code class="language-plaintext highlighter-rouge">HTML</code>页面,但是对于<code class="language-plaintext highlighter-rouge">API</code>请求则保持代理.你可以这样做:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = {
    //...
    devServer: {
        proxy: {
            /api': {
                target: 'http://localhost:3000',
                bypass: function(req, res, proxyOptions) {
                            if (req.headers.accept.indexOf('html') !== -1) {
                                console.log('Skipping proxy for browser request.');
                                return '/index.html';
                            }
                        }
            }
        }
    }
};
</code></pre></div></div>

<p>解决跨域原理:<br />
上面的参数列表中有一个<code class="language-plaintext highlighter-rouge">changeOrigin</code>参数,是一个布尔值,设置为<code class="language-plaintext highlighter-rouge">true</code>,本地就会虚拟一个服务器接收你的请求并代你发送该请求,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = {
    //...
    devServer: {
        proxy: {
            '/api': {
                target: 'http://localhost:3000',
                changeOrigin: true,
            }
        }
    }
};
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">vue-cli</code>中<code class="language-plaintext highlighter-rouge">proxyTable</code>配置接口地址代理示例<br />
修改<code class="language-plaintext highlighter-rouge">config/index.js</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = {
    dev: {
    // 静态资源文件夹
    assetsSubDirectory: 'static',
    // 发布路径
    assetsPublicPath: '/',
 
    // 代理配置表，在这里可以配置特定的请求代理到对应的API接口
    // 使用方法：https://vuejs-templates.github.io/webpack/proxy.html
    proxyTable: {
        // 例如将'localhost:8080/api/xxx'代理到'https://wangyaxing.cn/api/xxx'
        '/api': {
            target: 'https://wangyaxing.cn', // 接口的域名
            secure: false,  // 如果是https接口，需要配置这个参数
            changeOrigin: true, // 如果接口跨域，需要进行这个参数配置
        },
        // 例如将'localhost:8080/img/xxx'代理到'https://cdn.wangyaxing.cn/xxx'
        '/img': {
            target: 'https://cdn.wangyaxing.cn', // 接口的域名
            secure: false,  // 如果是https接口，需要配置这个参数
            changeOrigin: true, // 如果接口跨域，需要进行这个参数配置
            pathRewrite: {'^/img': ''}  // pathRewrite 来重写地址，将前缀 '/api' 转为 '/'。
        }
    },
    // Various Dev Server settings
    host: 'localhost', // can be overwritten by process.env.HOST
    port: 4200, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined
}
</code></pre></div></div>

<p>更多参数<br />
<code class="language-plaintext highlighter-rouge">dev-server</code>使用了非常强大的<code class="language-plaintext highlighter-rouge">http-proxy-middleware</code>,<code class="language-plaintext highlighter-rouge">http-proxy-middleware</code>基于<code class="language-plaintext highlighter-rouge">http-proxy</code>实现的，可以查看 <code class="language-plaintext highlighter-rouge">http-proxy</code>的<a href="https://github.com/nodejitsu/node-http-proxy">源码和文档</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>target：要使用url模块解析的url字符串
forward：要使用url模块解析的url字符串
agent：要传递给http（s）.request的对象（请参阅Node的https代理和http代理对象）
ssl：要传递给https.createServer（）的对象
ws：true / false，是否代理websockets
xfwd：true / false，添加x-forward标头
secure：true / false，是否验证SSL Certs
toProxy：true / false，传递绝对URL作为路径（对代理代理很有用）
prependPath：true / false，默认值：true - 指定是否要将目标的路径添加到代理路径
ignorePath：true / false，默认值：false - 指定是否要忽略传入请求的代理路径（注意：如果需要，您必须附加/手动）。
localAddress：要为传出连接绑定的本地接口字符串
changeOrigin：true / false，默认值：false - 将主机标头的原点更改为目标URL
使用中的注意要点：
使用fastmock模拟后端接口时，发现同样的三个接口，其中一个可以代理，另外两个不能代理，让人不能理解，具体配置方式如下所示：
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>devServer: {
    // development server port 8000
    port: '8000', // 开发模式默认端口
    proxy: {
        '/api': {
            target: 'http://10.203.13.66:8030', //实际的api地址
            ws: false,
            changeOrigin: true,
            pathRewrite: {
                '^/api': '/'
            }
        },
        '/ceshi': {
            target: 'https://www.fastmock.site/mock/e35a162557a2455f8ba553a72aae693c',
            ws: false,
            changeOrigin: true,
            pathRewrite: {
                '/ceshi': '/'
            }
        }
    }
}
</code></pre></div></div>

:ET